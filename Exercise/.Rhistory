#hPrice
hprice.dat <- read.table("Dataset/hprice.txt",header=TRUE)
hprice.dat
View(hprice.dat)
summary(hprice.dat)
hprice.lm1 <- lm(sale.price ~ lot.size + desire.loc,data=hprice.dat)
hprice.lm1
summary(hprice.lm1)
summary(hprice.dat)
# first you need to load the MASS package (you can also do this by selecting Load Package from the Packages menu).
library(MASS)
hprice.step <- stepAIC(hprice.lm2,scope=list(lower = ~1,upper = ~.^2),k=log(546))
# give a summary of the search process
hprice.step$anova
hprice.lm2 <- lm(sale.price ~ .,data=hprice.dat)
summary(hprice.lm2)
# first you need to load the MASS package (you can also do this by selecting Load Package from the Packages menu).
library(MASS)
hprice.step <- stepAIC(hprice.lm2,scope=list(lower = ~1,upper = ~.^2),k=log(546))
# give a summary of the search process
hprice.step$anova
summary(hprice.step)
x <- seq(0,1,len=10)
x <- seq(0,1,len=10)
x
t <- sin(2*pi*x)+rnorm(n=10,mean=0,sd=0.3)
t
plot(x,t,ylim=c(-2,2))
x.graph <- seq(0,1,by=0.001)
t.graph <- sin(2*pi*x.graph)
x.graph
t.graph
plot(x,t,ylim=c(-2,2))
lines(x.graph,t.graph,lwd=2,col=4)
install.packages("ridge")
install.packages("ridge", lib="S:/patrec/Rpackages/")
x.graph <- seq(0,1,by=0.001)
t.graph <- sin(2*pi*x.graph)
# plot the training set. You might want to adjust the value of ylim, depending on drawn data points and fitted functions
plot(x,t,ylim=c(-2,2))
# plot the "true" function
lines(x.graph,t.graph,lwd=2,col=4)
lm(t~x+I(x^2)+I(x^3),data.frame(t=t,x=x))
predict(poly.3,data.frame(x=x.graph))
# fit a 3rd order polynomial to the data
poly.3 <- lm(t~x+I(x^2)+I(x^3),data.frame(t=t,x=x))
predict(poly.3,data.frame(x=x.graph))
lines(x.graph,y.poly.3.graph,lwd=2,col=2)
lines(x.graph,y.poly.3.graph,lwd=2,col=2)
y.poly.3.graph <- predict(poly.3,data.frame(x=x.graph))
# plot the fitted function
lines(x.graph,y.poly.3.graph,lwd=2,col=2)
poly.9 <- lm(t~x+I(x^2)+I(x^3)+I(x^4)+I(x^5)+I(x^6)+I(x^7)+I(x^8)+I(x^9),data.frame(t=t,x=x))
summary(poly.9)
t.testset <- sin(2*pi*x.graph)+rnorm(n=1001,mean=0,sd=0.3)
error.poly.3 <- sum((y.poly.3.graph-t.testset)^2)
error.poly.9 <- sum((y.poly.9.graph-t.testset)^2)
error.poly.3 <- sum((y.poly.3.graph-t.testset)^2)
error.poly.3
y.poly.9.graph <- predict(poly.9,data.frame(x=x.graph))
lines(x.graph,y.poly.9.graph,lwd=2,col=6)
